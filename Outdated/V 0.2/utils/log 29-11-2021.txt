import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
from utils.elo_utilities import *
from utils.drive import *
from processing_match import *
from processing_delmail import *
from processing_drive import *

def main():

    print("Traitement matchs: match")
    print("Suppresion email: delmail")
    print("Mise Ã  jour du drive: drive")
    cmd = input("Cmd ?")
    cmd = cmd.split(" ")
    
    if cmd[0] == "match":
        processing_match()
    
    if cmd[0] == "delmail":
        processing_delmail()
        
    if cmd[0] == "drive":
        processing_drive()
    if cmd[0] == "":
        processing_match()
        i = 0
        for i in range(0,30):
            print("waiting until 30" + str(i))
            time.sleep(1)
        processing_delmail()
        i = 0
        for i in range(0,10):
            print("waiting until 10" + str(i))
            time.sleep(1)
        processing_drive()
        print("\n\n\nFIN")
    
    


if __name__ == "__main__":
    main()
import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
from utils.elo_utilities import *
from utils.drive import *
#from processing_match import *
#from processing_delmail import *
#from processing_drive import *


def processing_match():
    service = gmail_authenticate()
    senders = []
    contenu_mail = []
    results = search_messages(service, "Subject:TEST in:inbox")  
    for msg in results:
        contenu, sender = read_message(service, msg)
        sender = sender.split(" ")
        if not sender[-1] == 'babyfootsmc@gmail.com':
            senders.append(sender[-1])
            contenu_mail.append(contenu)
    i = 0 
    L_match = [] 
    classement = []
    print("[processing_match] " + str(senders))
    
     
    for i in range(len(contenu_mail)):
        match_str = str(contenu_mail[i])
        match_list = match_str.split("\r\n")
        print("[processing_match] " + match_str)
        if match_list[-1] == '':
            match_list.remove('')
        if len(match_list) == 4:
            player_A, player_A_Score = match_list[0].split(" ")
            player_B, player_B_Score = match_list[1].split(" ")
            player_C, player_C_Score = match_list[2].split(" ")
            player_D, player_D_Score = match_list[3].split(" ")
            
            print("[processing_match] " + "Joueur A:" + player_A)
            print("[processing_match] " + "Joueur B:" + player_B)
            print("[processing_match] " + "Joueur C:" + player_C)
            print("[processing_match] " + "Joueur D:" + player_D)
            print("[processing_match] " + "Joueur A Score:" + player_A_Score)
            print("[processing_match] " + "Joueur B Score:" + player_B_Score)
            print("[processing_match] " + "Joueur C Score:" + player_C_Score)
            print("[processing_match] " + "Joueur D Score:" + player_D_Score)
            if Test_for_Score(player_A_Score, player_B_Score, player_C_Score, player_D_Score):
                if Test_for_TeamScore(player_A_Score, player_B_Score, player_C_Score, player_D_Score):
                    if Test_for_player(player_A, player_B, player_C, player_D):
                
                        
                        player_A = clean_name(player_A)
                        player_B = clean_name(player_B)
                        player_C = clean_name(player_C)
                        player_D = clean_name(player_D)
                        player_A_Elo = get_elo(player_A)
                        player_B_Elo = get_elo(player_B)
                        player_C_Elo = get_elo(player_C)
                        player_D_Elo = get_elo(player_D)  
                        
                        print("[processing_match] " + "Elo Joueur A : " + str(player_A_Elo)) 
                        print("[processing_match] " + "Elo Joueur B : " + str(player_B_Elo))
                        print("[processing_match] " + "Elo Joueur C : " + str(player_C_Elo))
                        print("[processing_match] " + "Elo Joueur D : " + str(player_D_Elo))               
                        Team_1_Elo = team_elo(player_A_Elo, player_B_Elo)
                        Team_2_Elo = team_elo(player_C_Elo, player_D_Elo) 
                        print("[processing_match] " + "Elo Team 1 : " + str(Team_1_Elo))
                        print("[processing_match] " + "Elo Team 2 : " + str(Team_2_Elo))   
                        match(player_A, player_A_Score, Team_1_Elo, Team_2_Elo)
                        match(player_B, player_B_Score, Team_1_Elo, Team_2_Elo)
                        match(player_C, player_C_Score, Team_2_Elo, Team_1_Elo)
                        match(player_D, player_D_Score, Team_2_Elo, Team_1_Elo)
                        print("[processing_match] " + "DONE: " + str(match_list))
                        
                    else:
                        print("[processing_match] " + "Pas 4 joueurs differents ")
                        send_message(service, senders[i], "Elo Rating SMC Program", "Format invalide pour l'email\n" + str(match_list) + '\n\nVeuillez mettre 4 joueurs differents')                  
                else: 
                    send_message(service, senders[i], "Elo Rating SMC Program", "Format invalide pour l'email\n" + str(match_list) + '\n\nVeuillez mettre V en cas de victoire ou D en cas de faite. \nIl ne peut pas y avoir plus de 2 gagnant ni plus de 2 perdant')
                    print("[processing_match] " + "Plus de 2 gagnant ou plus de deux perdant")
            else: 
                send_message(service, senders[i], "Elo Rating SMC Program", "Format invalide pour l'email\n" + str(match_list) + '\n\nVeuillez mettre V en cas de victoire ou D en cas de faite')
                print("[processing_match] " + "Pas de V ou de D")    
        else:     
            
            send_message(service, senders[i], "Elo Rating SMC Program", "Format invalide pour l'email\n" + str(match_list))
            print("[processing_match] " + "Format Invalide")
    print("[processing_match] " + "Done")

import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
from utils.elo_utilities import *
from utils.drive import *
from processing_match import *
from processing_delmail import *
#from processing_drive import *




SCOPES = ['https://mail.google.com/',
          'https://www.googleapis.com/auth/drive.metadata',
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/drive.file'
          ]

def processing_drive():
    service = get_gdrive_service()
    main_folder = '19B8pLM-jO4F6YvlrZGP8S02PGCI6LEDo'
    today = str(date.today())
    print("[processing_drive]" + today)
    
    classement = get_classement()
    filename = "classement " + today + ".txt"
    print("[processing_drive] filename: " + filename)
    
    file = open(filename, "w")
    i = 0
    
    for i in range(len(classement)):
        classement[i][1] = str(classement[i][1])
        file.write(" ".join(classement[i]) + "\n")
    file.close()
    upload_files(filename, main_folder)
    print("[processing_drive] uploaded:" + filename + "  in: " + main_folder)
    if os.path.exists(filename):
        os.remove(filename)
        print("[processing_drive] deleting cache file " + filename)
    else:
        print("[processing_drive] The file does not exist")
    
    i = 0
    for i in range(len(classement)):
        folder_id = search_for_folder(classement[i][0])
        
        if folder_id == "false":
            folder_metadata = {
                "name": classement[i][0],
                "mimeType": "application/vnd.google-apps.folder",
                "parents": [main_folder]
            }
            folder = service.files().create(body=folder_metadata, fields="id").execute()
            folder_id = folder.get("id")
            filename = str(classement[i][0] + " " + today + ".txt")
            print("[processing_drive] creating cache file " + filename)
            file = open(filename, "w")
            classement[i][1] = str(classement[i][1])
            file.write(" ".join(classement[i]) + "\n")
            file.close()
            upload_files(filename, folder_id)
            print("[processing_drive] uploaded:" + filename + "  in: " + folder_id)
                
            if os.path.exists(filename):
                os.remove(filename)
                print("[processing_drive] deleting cache file " + filename)
            else:
                print("[processing_drive] The file does not exist")
        else: 
            filename = str(classement[i][0] + " " + today + ".txt")
            file = open(filename, "w")
            classement[i][1] = str(classement[i][1])
            file.write(" ".join(classement[i]) + "\n")
            file.close()
            print("[processing_drive] creating cache file " + filename)
            upload_files(filename, folder_id)
            print("[processing_drive] uploaded:" + filename + "  in: " + main_folder)
                    
            if os.path.exists(filename):
                os.remove(filename)
                print("[processing_drive] deleting cache file " + filename)
            else:
                print("[processing_drive] The file does not exist")
import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
from utils.elo_utilities import *
from utils.drive import *
from processing_match import *
#from processing_delmail import *
from processing_drive import *


def processing_delmail(): 
    service = gmail_authenticate()
    delete_messages(service, "Subject:TEST in:inbox")

import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

#from utils.mail import *
from utils.elo_utilities import *
from utils.drive import *
#from processing_match import *
#from processing_delmail import *
#from processing_drive import *
#Ask for all perms on this email
SCOPES = ['https://mail.google.com/',
          'https://www.googleapis.com/auth/drive.metadata',
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/drive.file'
          ]
our_email = 'babyfootsmc@gmail.com'





#GMAIL_AUTHENTICATE==================================================
def gmail_authenticate():
    
    creds = None
    # the file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first time
    if os.path.exists("token.pickle"):
        with open("token.pickle", "rb") as token:
            creds = pickle.load(token)
    # if there are no (valid) credentials availablle, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file('credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # save the credentials for the next run
        with open("token.pickle", "wb") as token:
            pickle.dump(creds, token)
    print("[mail] " + "google_authenticate")
    return build('gmail', 'v1', credentials=creds)
#==================================================


#SEARCH_MESSAGE(service, str query)==================================================
def search_messages(service, query):
    '''
    query: str
    service: gmail_authenticate()
    '''
    result = service.users().messages().list(userId='me',q=query).execute()
    messages = [ ]
    if 'messages' in result:
        messages.extend(result['messages'])
    while 'nextPageToken' in result:
        page_token = result['nextPageToken']
        result = service.users().messages().list(userId='me',q=query, pageToken=page_token).execute()
        if 'messages' in result:
            messages.extend(result['messages'])
    return messages
#==================================================

#GET_SIZE_FORMAT(int nbe_bytes)==================================================
def get_size_format(b, factor=1024, suffix="B"):
    """
    Scale bytes to its proper byte format
    e.g:
        1253656 => '1.20MB'
        1253656678 => '1.17GB'
    """
    for unit in ["", "K", "M", "G", "T", "P", "E", "Z"]:
        if b < factor:
            return f"{b:.2f}{unit}{suffix}"
        b /= factor
    return f"{b:.2f}Y{suffix}"
#==================================================


#CLEAN (str text)==================================================
def clean(text):
    # clean text for creating a folder
    print("[mail] " + "cleaning " + text) 
    return "".join(c if c.isalnum() else "_" for c in text)
    #==================================================


#PARSE_PARTS(service, parts, folder_name, message)==================================================
def parse_parts(service, parts, folder_name, message):
    """
    Utility function that parses the content of an email partition
    """
    if parts:
        for part in parts:
            filename = part.get("filename")
            mimeType = part.get("mimeType")
            body = part.get("body")
            data = body.get("data")
            file_size = body.get("size")
            part_headers = part.get("headers")
            if part.get("parts"):
                # recursively call this function when we see that a part
                # has parts inside
                parse_parts(service, part.get("parts"), folder_name, message)
            if mimeType == "text/plain":
                # if the email part is text plain
                if data:
                    text = urlsafe_b64decode(data).decode()
                    print(text)
                    fichier = open("mail/" + str(folder_name) + "/info.txt", "a")
                    fichier.write(str("\n\n\nTexte:\n\n"))
                    fichier.write(text)
                    return text
            elif mimeType == "text/html":
                # if the email part is an HTML content
                # save the HTML file and optionally open it in the browser
                if not filename:
                    filename = "index.html"
                filepath = os.path.join("mail/" + folder_name, filename)
                
                print("Saving HTML to", filepath)
                with open(filepath, "wb") as f:
                    f.write(urlsafe_b64decode(data))
            else:
                # attachment other than a plain text or HTML
                for part_header in part_headers:
                    part_header_name = part_header.get("name")
                    part_header_value = part_header.get("value")
                    if part_header_name == "Content-Disposition":
                        if "attachment" in part_header_value:
                            # we get the attachment ID 
                            # and make another request to get the attachment itself
                            print("Saving the file:", filename, "size:", get_size_format(file_size))
                            attachment_id = body.get("attachmentId")
                            attachment = service.users().messages() \
                                        .attachments().get(id=attachment_id, userId='me', messageId=message['id']).execute()
                            data = attachment.get("data")
                            filepath = os.path.join(folder_name, filename)
                            if data:
                                with open(filepath, "wb") as f:
                                    f.write(urlsafe_b64decode(data))
    #==================================================


#READ_MESSAGE(service, list return (search_mail)==================================================
def read_message(service, message):
    """
    This function takes Gmail API `service` and the given `message_id` and does the following:
        - Downloads the content of the email
        - Prints email basic information (To, From, Subject & Date) and plain/text parts
        - Creates a folder for each email based on the subject
        - Downloads text/html content (if available) and saves it under the folder created as index.html
        - Downloads any file that is attached to the email and saves it in the folder created
    """
    msg = service.users().messages().get(userId='me', id=message["id"], format='full').execute()
    # parts can be the message body, or attachments
    payload = msg['payload']
    headers = payload.get("headers")
    headers_save = []
    parts = payload.get("parts")
    folder_name = "email"
    print("="*50)
    has_subject = False
    if headers:
        # this section prints email basic info & creates a folder for the email
        for header in headers:
            name = header.get("name")
            value = header.get("value")
            if name.lower() == 'from':
                # we print the From address
                print("From:", value)
                headers_save.append(str("From: " + value + "\n"))
                sender = value 
            if name.lower() == "to":
                # we print the To address
                print("To:", value)
            if name.lower() == "subject":
                # make our boolean True, the email has "subject"
                headers_save.append(str("Subject: " + value + "\n"))
                has_subject = True
                # make a directory with the name of the subject
                folder_name = clean(value)
                # we will also handle emails with the same subject name
                folder_counter = 0
                if not os.path.exists("mail/"):
                    os.mkdir("mail/")
                while os.path.isdir("mail/" + folder_name):
                    folder_counter += 1
                    folder_name = str(clean(value) + "__" +  str(folder_counter))
                os.mkdir(str("mail/" + folder_name))
                #print("Subject:", value)    
            if name.lower() == "date":
                # we print the date when the message was sent
                print("Date:", value)
                headers_save.append(str("Date: " + value + "\n"))
    if not has_subject:
        # if the email does not have a subject, then make a folder with "email" name
        # since folders are created based on subjects
        if not os.path.isdir("mail/" + folder_name):
            os.mkdir(str("mail/" + folder_name))
    text = parse_parts(service, parts, folder_name, message)
    fichier = open("mail/" + str(folder_name) + "/info.txt", "w")
    fichier.write(str("\n".join(headers_save)))
    fichier.close()
    print("="*50) 
    return text, sender
    #==================================================

#build_message(str email, str objet, str body)==================================================
def build_message(destination, obj, body):  
    message = MIMEText(body)
    message['to'] = destination
    message['from'] = our_email
    message['subject'] = obj
    return {'raw': urlsafe_b64encode(message.as_bytes()).decode()}
    #==================================================

#SEND_MESSAGE(servicd, str email , str obj, str body)==================================================
def send_message(service, destination, obj, body):
    print("[mail] " + "send message: " + "\n" + destination + "\n" + obj + "\n" + body)
    print("[mail] " + "message sended")
    return service.users().messages().send(userId="me",body=build_message(destination, obj, body)).execute()
    #==================================================

#DELETE_MESSAGE(service,str recherche)==================================================
def delete_messages(service, query):
    messages_to_delete = search_messages(service, query)
    # it's possible to delete a single message with the delete API, like this:
    # service.users().messages().delete(userId='me', id=msg['id'])
    # but it's also possible to delete all the selected messages with one query, batchDelete
    print("[mail] " + "deleting")
    return service.users().messages().batchDelete(
      userId='me',
      body={
          'ids': [ msg['id'] for msg in messages_to_delete]
      }
    ).execute()
    #==================================================

#==================================================   
def mark_as_unread(service, query):
    messages_to_mark = search_messages(service, query)
    return service.users().messages().batchModify(
        userId='me',
        body={
            'ids': [ msg['id'] for msg in messages_to_mark ],
            'addLabelIds': ['UNREAD']
        }
    ).execute()
    #==================================================


import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
#from utils.elo_utilities import *
from utils.drive import *
#from processing_match import *
#from processing_delmail import *
#from processing_drive import *


#excepted(int score_A, int score_B)==================================================
def excepted(A, B):
    return 1/(1+10**((B-A)/400))
#==================================================


#elo(int previous_elo_A, int previous_elo_B, int state_for_A)=================
def elo(elo_A, elo_B, state_for_A):
    k = 40
    return (k*(state_for_A - excepted(elo_A, elo_B)))
    #==================================================
    
#GET_CLASSEMENT==================================================
def get_classement():
    classement = []
    fichier = open('elo.py', 'r')
    for ligne in fichier:
        if not ligne == "\n":
            classement.append(ligne)
            print("[elo_utilities] " + classement[-1])
    fichier.close()
    i = 0
    for i in range(len(classement)):
        x = 0
        x = classement[i]
        x = str(x).split(" ")
        y = x[-1] 
        x[-1] = y.split("\n")[0]
        x[-1] = int(x[-1])
        classement[i] = []
        classement[i] = x 
    return classement
    #==================================================

#GET_ELO(str pseudo)==================================================
def get_elo(target):
    classement = get_classement()
    i = 0
    elo_target = 0
    
    if target == "personne":
        return 0
    for i in range(len(classement)):
        if str(classement[i][0]) == str(target): 
            elo_target = int(classement[i][1])
            print("[elo_utilities] " + target + ": " + str(elo_target) + "Elo")
            return elo_target
    
    fichier = open('elo.py', 'a')
    fichier.write(target + ' 1000\n')
    print("[elo_utilities] " + "[New Player added] " + target)
    fichier.close()
    return 1000
    #==================================================


#SET_ELO(str pseudo, int nouvel elo)==================================================
def set_elo(target, elo):
    classement = get_classement()
    i = 0
    elo_target = 0
    for i in range(len(classement)):
        classement = get_classement()
        if str(classement[i][0]) == str(target): 
            classement[i][1] = str(str(elo) + "\n")
            fichier = open('elo.py', 'w')
            j = 0
            for j in range(len(classement)):
                
                classement[j][1] = str(classement[j][1])
                print("[elo_utilities] " + str(classement[j]))
                classement_save = " ".join(classement[j])
                fichier.write(str(classement[j][0] + " " + str(classement[j][1]) +"\n"))
            fichier.close()
    return   
    #==================================================

#MATCH(str joueur, int issue[0 ou 1], int Elo_Team_Joueur, int Elo_Team_Adversaire =======================
def match(Player, player_Score, Team_1, Team_2):
    player_Elo = get_elo(Player)
    if player_Score == "V":
        player_Score = 1
    elif player_Score == "D":
        player_Score = 0
    player_Elo += elo(Team_1, Team_2,player_Score)
    set_elo(Player, int(player_Elo))
    return
    #==================================================


#TEAM_ELO(int JoueurA, int JoueurB)==================================================
def team_elo(Player_A_Elo, Player_B_Elo):   
    team_elo = (1.2*max(Player_A_Elo, Player_B_Elo)+min(Player_A_Elo, Player_B_Elo))/2
    return team_elo
    #==================================================
    
#==================================================
def clean_name(string):
    string = string.replace("Ã¢", "a")
    string = string.replace("Ã¦", "ae")
    string = string.replace("Ã ", "a")
    string = string.replace("Ãª", "e")
    string = string.replace("Ã©", "e")
    string = string.replace("Ã¨", "e")
    string = string.replace("Ã«", "e")
    string = string.replace("Ã®", "i")
    string = string.replace("Ã¯", "i")
    string = string.replace("Ã¬", "i")
    string = string.replace("Ã­", "i")
    string = string.replace("Ã¶", "o")
    string = string.replace("Ã³", "o")
    string = string.replace("Ã´", "o")
    string = string.replace("Å", "oe")
    string = string.replace("Ã²", "o")
    string = string.replace("Ã¼", "u")
    string = string.replace("Ã»", "u")
    string = string.replace("Ã¹", "u")
    string = string.replace("Ãº", "u")
    string = string.replace("Ã¿", "y")
    return string
    #==================================================
#==================================================
def Test_for_Score(player_A_Score, player_B_Score, player_C_Score, player_D_Score):
    
    A = (player_A_Score == 'V' or player_A_Score == 'D')
    B = (player_B_Score == 'V' or player_B_Score == 'D')
    C = (player_C_Score == 'V' or player_C_Score == 'D')
    D = (player_D_Score == 'V' or player_D_Score == 'D')
    
    if A and B and C and D:
        return True
    else:
        return False 
    #==================================================

#==================================================
def Test_for_TeamScore(player_A_Score, player_B_Score, player_C_Score, player_D_Score):
    A = player_A_Score == player_B_Score 
    B = player_C_Score == player_D_Score 
    C = player_A_Score != player_D_Score
    if A and B and C:
        return True
    else:
        return False 
    #==================================================

#==================================================
def Test_for_player(player_A, player_B, player_C, player_D):
    if player_A == "personne" or player_B == "personne" or player_C == "personne" or player_D == "personne":
        A = player_A != player_B or player_A == "personne" or player_B == "personne"
        B = player_C != player_D or player_C == "personne" or player_D == "personne"
        C = player_A != player_D or player_A == "personne" or player_D == "personne"
        D = player_B != player_C or player_B == "personne" or player_C == "personne"
        
        print("[elo_utilities] A = " + str(A) + " B = " + str(B) + " C = " + str(C) + " D = " + str(D))
    
    else:
        A = player_A != player_B
        B = player_C != player_D
        C = player_A != player_D
        D = player_B != player_C
        
        print("[elo_utilities] A = " + str(A) + " B = " + str(B) + " C = " + str(C) + " D = " + str(D))
    if A and B and C and D:
        return True
    else: 
        return False
    #==================================================

import pickle
import os
import re
import io
import requests
import time
from datetime import date
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from googleapiclient.http import MediaIoBaseDownload
from googleapiclient.http import MediaFileUpload
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.image import MIMEImage
from email.mime.audio import MIMEAudio
from email.mime.base import MIMEBase
from mimetypes import guess_type as guess_mime_type
from base64 import urlsafe_b64decode, urlsafe_b64encode
from tqdm import tqdm
from tabulate import tabulate

from utils.mail import *
from utils.elo_utilities import *
#from utils.drive import *
#from processing_match import *
#from processing_delmail import *
#from processing_drive import *

# If modifying these scopes, delete the file token.pickle.
SCOPES = ['https://www.googleapis.com/auth/drive.metadata',
          'https://www.googleapis.com/auth/drive',
          'https://www.googleapis.com/auth/drive.file',
          'https://mail.google.com/'
          ]

#GET_GDRIVE_SERVICE==================================================
def get_gdrive_service():
    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.pickle'):
        with open('token.pickle', 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open('token.pickle', 'wb') as token:
            pickle.dump(creds, token)
    # return Google Drive API service
    print("[drive] get_gdrive_service")
    return build('drive', 'v3', credentials=creds)
    #==================================================
    
    
#SHOW_FILES_ACCES(int number of file to show)==================================================
def show_files_acces(n):
    service = get_gdrive_service()
    # Call the Drive v3 API
    results = service.files().list(
        pageSize=n, fields="nextPageToken, files(id, name, mimeType, size, parents, modifiedTime)").execute()
    # get the results
    items = results.get('files', [])
    # list all n files & folders
    list_files(items)
    #==================================================

#LIST_FILES(items)==================================================  
def list_files(items):
    """given items returned by Google Drive API, prints them in a tabular way"""
    if not items:
        # empty drive
        print('No files found.')
    else:
        rows = []
        for item in items:
            # get the File ID
            id = item["id"]
            # get the name of file
            name = item["name"]
            try:
                # parent directory ID
                parents = item["parents"]
            except:
                # has no parrents
                parents = "N/A"
            try:
                # get the size in nice bytes format (KB, MB, etc.)
                size = get_size_format(int(item["size"]))
            except:
                # not a file, may be a folder
                size = "N/A"
            # get the Google Drive type of file
            mime_type = item["mimeType"]
            # get last modified date time
            modified_time = item["modifiedTime"]
            # append everything to the list
            rows.append((id, name, parents, size, mime_type, modified_time))
        print("Files:")
        # convert to a human readable table
        table = tabulate(rows, headers=["ID", "Name", "Parents", "Size", "Type", "Modified Time"])
        # print the table
        print(table)
        #==================================================

#UPLOAD_FILES(str filename, str folder_id if none, root)==================================================
def upload_files(file_name, folder_id):
    """
    Creates a folder and upload a file to it
    """
    # authenticate account
    service = get_gdrive_service()
    file_metadata = {
        "name": file_name,
        "parents": [folder_id],
    }
    print("[drive] " + str(file_metadata))
    # upload
    media = MediaFileUpload(file_name, resumable=True)
    print("[drive] Uploading:" + file_name)
    file = service.files().create(body=file_metadata, media_body=media, fields='id').execute()
    print("[drive] File created, id:", file.get("id"))
    #==================================================


#SEARCH_FOR_FOLDER(str foldername to search for)==================================================
def search_for_folder(foldername):
    page_token = None
    service = get_gdrive_service()

    response = service.files().list(q="mimeType = 'application/vnd.google-apps.folder'",
                                    spaces='drive',
                                    fields='nextPageToken, files(id, name, mimeType)',
                                    pageToken=page_token).execute()
    print(str(response))
    #print('resp')
    for file in response.get('files', []):
        print("[drive] Search for folder:" + file.get('name'))
        if file.get('name') == foldername:
            print(file.get('id'))
            return file.get('id')
    return 'false'
    #==================================================

#SEARCH (service, str search)==================================================
def search(service, query):
    # search for the file
    result = []
    page_token = None
    while True:
        response = service.files().list(q=query,
                                        spaces="drive",
                                        fields="nextPageToken, files(id, name, mimeType)",
                                        pageToken=page_token).execute()
        # iterate over filtered files
        for file in response.get("files", []):
            result.append((file["id"], file["name"], file["mimeType"]))
        page_token = response.get('nextPageToken', None)
        if not page_token:
            # no more files
            break
    return result
    #==================================================

#SEARCH_FOR_FILES(str filetype)==================================================
def search_for_files(filetype):
    # filter to text files
    #filetype = "text/plain"
    
    # authenticate Google Drive API
    service = get_gdrive_service()
    # search for files that has type of text/plain
    search_result = search(service, query=f"mimeType='{filetype}'")
    # convert to table to print well
    table = tabulate(search_result, headers=["ID", "Name", "Type"])
    print(table)
    #==================================================


#DOWNLOAD_FILES_FROM_GOOGLE_DRIVE(id, str destination)==================================================
def download_file_from_google_drive(id, destination):
    def get_confirm_token(response):
        for key, value in response.cookies.items():
            if key.startswith('download_warning'):
                return value
        return None

    def save_response_content(response, destination):
        CHUNK_SIZE = 32768
        # get the file size from Content-length response header
        file_size = int(response.headers.get("Content-Length", 0))
        # extract Content disposition from response headers
        content_disposition = response.headers.get("content-disposition")
        # parse filename
        filename = re.findall("filename=\"(.+)\"", content_disposition)[0]
        print("[+] File size:", file_size)
        print("[+] File name:", filename)
        progress = tqdm(response.iter_content(CHUNK_SIZE), f"Downloading {filename}", total=file_size, unit="Byte", unit_scale=True, unit_divisor=1024)
        with open(destination, "wb") as f:
            for chunk in progress:
                if chunk: # filter out keep-alive new chunks
                    f.write(chunk)
                    # update the progress bar
                    progress.update(len(chunk))
        progress.close()

    # base URL for download
    URL = "https://docs.google.com/uc?export=download"
    # init a HTTP session
    session = requests.Session()
    # make a request
    response = session.get(URL, params = {'id': id}, stream=True)
    print("[+] Downloading", response.url)
    # get confirmation token
    token = get_confirm_token(response)
    if token:
        params = {'id': id, 'confirm':token}
        response = session.get(URL, params=params, stream=True)
    # download to disk
    save_response_content(response, destination)  
    #==================================================

#DOWNLOAD(str Filename)==================================================
def download(filename):
    service = get_gdrive_service()
    # the name of the file you want to download from Google Drive 
    #filename = "bbc.zip"
    # search for the file by name
    search_result = search(service, query=f"name='{filename}'")
    # get the GDrive ID of the file
    file_id = search_result[0][0]
    # make it shareable
    service.permissions().create(body={"role": "reader", "type": "anyone"}, fileId=file_id).execute()
    # download file
    download_file_from_google_drive(file_id, filename)
    #==================================================
